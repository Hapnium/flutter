import 'enums/log_level.dart';
import 'enums/log_type.dart';
import 'log_printer.dart';
import 'models/log_record.dart';
import 'printers/flat_printer.dart';
import 'printers/flat_structured_printer.dart';
import 'printers/fmt_printer.dart';
import 'printers/hybrid_printer.dart';
import 'printers/prefix_printer.dart';
import 'printers/pretty_printer.dart';
import 'printers/pretty_structured_printer.dart';
import 'printers/simple_printer.dart';

/// {@template application_log_listener}
/// A listener interface for reacting to logging events within an application.
///
/// The [TracingListener] interface allows you to observe and respond to log messages
/// generated by instances of [TracingListener]. This is useful for implementing
/// custom log processing, such as writing logs to:
///
/// - The console (standard output)
/// - External log files
/// - Remote logging services (e.g., Datadog, Sentry)
/// - In-memory dashboards or UIs
///
/// ### How to Implement
///
/// To respond to logs, implement this interface and override [onLog]:
///
/// ```dart
/// class ConsoleLogListener implements TracingListener {
///   @override
///   void onLog(LogLevel level, DateTime timestamp, String message, String tag) {
///     print('[$timestamp][$tag][$level] $message');
///   }
/// }
/// ```
///
/// ### Integration with Logger Factory
///
/// Register the listener with a logger:
///
/// ```dart
/// final logger = MyLoggerFactory("DatabaseService");
/// logger.registerListener(ConsoleLogListener());
///
/// logger.add(LogLevel.info, "Database connection established.");
/// ```
///
/// This enables a plug-and-play model where multiple listeners can be registered and
/// independently respond to log events.
///
/// {@endtemplate}
abstract class TracingListener {
  /// {@macro application_log_listener}
  LogLevel _level;

  /// {@macro application_log_listener}
  LogPrinter _printer;

  /// {@macro application_log_listener}
  void Function(String)? _output;

  String _name;

  /// {@macro application_log_listener}
  TracingListener({
    LogLevel level = LogLevel.INFO,
    LogPrinter? printer,
    LogType type = LogType.SIMPLE,
    void Function(String)? output,
    String name = "",
  }) : _level = level, _printer = printer ?? _getPrinter(type), _output = output, _name = name;

  /// {@macro application_log_listener}
  /// 
  /// Gets the printer based on the type.
  static LogPrinter _getPrinter(LogType type) {
    switch (type) {
      case LogType.PRETTY:
        return PrettyPrinter();
      case LogType.PRETTY_STRUCTURED:
        return PrettyStructuredPrinter();
      case LogType.FLAT:
        return FlatPrinter();
      case LogType.FLAT_STRUCTURED:
        return FlatStructuredPrinter();
      case LogType.PREFIX:
        return PrefixPrinter();
      case LogType.FMT:
        return FmtPrinter();
      case LogType.HYBRID:
        return HybridPrinter();
      case LogType.SIMPLE:
        return SimplePrinter();
    }
  }

  /// Called when a new log entry is emitted by a logger.
  ///
  /// This method provides complete context about the log event, including:
  /// - [level]: the severity or type of the log (e.g., info, error, debug)
  /// - [timestamp]: the exact time the log entry was recorded
  /// - [message]: the textual content of the log
  /// - [tag]: the name or label of the logger that emitted the message
  ///
  /// This method is called immediately after the message is stored in the loggerâ€™s
  /// internal buffer, allowing real-time response.
  ///
  /// ### Example
  /// ```dart
  /// void onLog(LogLevel level, DateTime timestamp, String message, String tag) {
  ///   sendToRemoteServer({
  ///     'level': level.name,
  ///     'time': timestamp.toIso8601String(),
  ///     'source': tag,
  ///     'log': message,
  ///   });
  /// }
  /// ```
  void onLog(LogLevel level, dynamic message, {String? tag, Object? error, StackTrace? stackTrace}) {
    if (!_level.isEnabledFor(level)) return;

    final record = LogRecord(
      level,
      message.toString(),
      loggerName: tag ?? _name,
      error: error,
      stackTrace: stackTrace,
    );

    final lines = _printer.log(record);
    final outputFn = _output ?? _defaultOutput;
    
    for (final line in lines) {
      outputFn(line);
    }
  }

  void _defaultOutput(String message) {
    print(message);
  }
}